ABrotate   :   #bestok.ABrotate( hp.point, hp.point + hp.unitVector, hp.angle )
abspath   :   return os.path.abspath(dirname)
add   :   tot.add(d2)
Add   :   dna.Add(new,mov)
AddAtom   :   newRig.AddAtom(a)
AddCoord   :   c.AddCoord(coo2)
addfinalizer   :   request.addfinalizer(teardown)
AddLigand   :   forcefield.AddLigand(lig)
add_argument   :   parser.add_argument('-o', '--output',
add_mutually_exclusive_group   :   group = parser.add_mutually_exclusive_group()
add_parser   :   parser = parent.add_parser('extract', help=__doc__)
add_subparsers   :   subparsers = parser.add_subparsers()
append   :   axislist.append(model)
Apply   :   newPB.Apply(m)
ApplyLocal   :   dna.ApplyLocal(Roll(30), dna.Size() / 2)
ApplyMatrix   :   mobil.ApplyMatrix(m)
apply_matrix   :   ligand.apply_matrix(m)
assertAlmostEqual   :   self.assertAlmostEqual(ener, -51.6955215854)
assertEqual   :   self.assertEqual(dna.Size(), 231)
assertFalse   :   self.assertFalse(coordinates_equal(origin, self.r.FindCenter()))  # assertEqual won't work
assertLess   :   self.assertLess(abs(dz + 5.0), tolerance)
assertListEqual   :   self.assertListEqual(ref, res)
assertMatrixAlmostEqual   :   self.assertMatrixAlmostEqual(get_movement_matrix(mov), self.target)
assertNotEqual   :   self.assertNotEqual(s, '')
assertRaises   :   self.assertRaises(RuntimeError, Rmsd, "hello", self.rigid1)
assertRaisesRegexp   :   with self.assertRaisesRegexp(OverflowError, "can't convert negative value to unsigned int"):
assertSameDimensions   :   self.assertSameDimensions(source, target)
assertTrue   :   self.assertTrue(filecmp.cmp(TEST_LIGAND_RED_SCORPION_CGOPT, self.output_name))
assert_equal   :   errors += trans1.assert_equal(trans2)
atan   :   #beta = math.atan(hpori.normtranslation*2*math.pi/(2*rayon*hpori.angle))
Atom   :   return ptools.Atom(self, self.coords)
AttractEulerRotate   :   output.AttractEulerRotate(surreal(X[0]), surreal(X[1]), surreal(X[2]))
b64decode   :   compressed = base64.b64decode(f)
b64encode   :   encoded = base64.b64encode(compressed)
Backbone   :   ligBBInterface = ligprobe.Backbone() & selectListOfResidues(ligprobe,ligResidues) #interface bb residues of docked ligand
CA   :   refca = ref.CA()
ceil   :   if enerk(rec,templig,1+math.ceil(nbmono),144) > 10:
center_to_origin   :   self.r.center_to_origin()
ChangeRepresentation   :   dna.ChangeRepresentation(PB_AA)
ChangeType   :   dna.ChangeType(0, "A", TEST_BP_RED)
check_composition   :   coarse_res.check_composition()
check_ff_version_match   :   ff_name = ptools.io.check_ff_version_match(args.receptor_name, args.ligand_name)
check_file_exists   :   ptools.io.check_file_exists(args.ligand)
close   :   #f.close()
cmp   :   assert filecmp.cmp(TEST_SINGLEMINIM_MINIMIZATION_OUT, output_name) is True
compile   :   regexp = re.compile("[0-9]+:[0-9]+")  # filter keys of the form "23:356"
compress   :   compressed = bz2.compress(all)
compress_file   :   print(docking.compress_file('attract.inp'))
CopyAtom   :   ABrotate( model.CopyAtom(0).GetCoords(), model.CopyAtom(1).GetCoords(), bp, math.radians(angle) )
copyfile   :   shutil.copyfile(TEST_DOCKING_TRANSLATION, 'translation.dat')
cos   :   #axn = math.cos(beta) * axe + -math.sin(beta) * vectn/Norm(vectn)
Counter   :   counter = collections.Counter(self.found_atoms)
create   :   bead = beadcreator.create()
createRigid   :   rtot = tot.createRigid()
CreateRigid   :   #dnaRig= dnaRig + dna.CreateRigid()
create_subparser   :   extract_cmd.create_subparser(subparsers)
critical   :   ptools.io.critical("option --delgrid requires --ff=scorpion",
decompress   :   file = bz2.decompress(compressed)
dedent   :   content = textwrap.dedent("""
deepcopy   :   self._lstofAtoms = copy.deepcopy(lstofAtoms)
degrees   :   pitch = abs(hp.normtranslation*(360./(abs(math.degrees(hp.angle)))))
detach   :   self.mat.detach()
dirname   :   project_root = os.path.dirname(cwd)
endswith   :   if filename.endswith(suffix):
error   :   parser.error("please specify molecule type (--prot or --dna) and atomic file")
exception_names_to_exception_list   :   ignore_exceptions = ptools.exceptions.exception_names_to_exception_list(args.ignore_error)
exists   :   if not os.path.exists(name):
exit   :   sys.exit(1)
exp   :   #print >>sys.stderr, "*", i, oldener, newener, Rmsd(ref,ligTemp), fpib, delta, math.exp(-delta/ftemp)
extend   :   boolean_options.extend(['use_legacy_boost'])
Extractor   :   e = extract.Extractor(outputfile)  # extracts output structures or reuse the generated database
fabs   :   nbb = 2*math.pi/math.fabs(hp.angle)
finalize_options   :   _build_ext.finalize_options(self)
FindCenter   :   pj = monoj.FindCenter()
floor   :   listn = [int(math.floor(nbb)), int(math.ceil(nbb))]
flush   :   file.flush()
format   :   copyright = u"{}, {}".format(datetime.datetime.now().year, AUTHORS)
format_matrix   :   other.format_matrix())
from_file   :   return AttractOutput.from_file(path)
from_string   :   return AttractOutput.from_string(content)
func   :   args.func(args)
get   :   descriptions = beadCorresp.get(residname, [])
GetAtomProperty   :   ires = rtot.GetAtomProperty(i).GetResidId()
GetChainId   :   cc = at.GetChainId()
getCoords   :   coord = outergrid.getCoords(i)
GetCoords   :   X= Atom(at,proj.GetCoords()+(AB*distX))
getcwd   :   cwd = os.getcwd()
GetMatrix   :   m=(Twist( 35.9063052632 )+Roll( -2.66592947368 )+Tilt( -1.80234789474 )+Slide( -1.34487389474 )+Shift( -0.425181378947 )).GetMatrix();
getmembers   :   return [name for name, obj in inspect.getmembers(sys.modules[__name__])
GetMinimizedVars   :   X = lbfgs_minimizer.GetMinimizedVars()  # optimized freedom variables after minimization
GetMinimizedVarsAtIter   :   traj = lbfgs_minimizer.GetMinimizedVarsAtIter(iteration)
GetNumberIter   :   ntraj = lbfgs_minimizer.GetNumberIter()
getopt   :   options, patterns = getopt.getopt(sys.argv[1:], 'o:r:',
GetResidId   :   jres = ati.GetResidId()
GetRigidBody   :   bp = dna[i].GetRigidBody()
getStructure   :   lig3 = e.getStructure(lig, "%i:%i" % (transNB, rotNB))
GetType   :   nami = ati.GetType()
get_atom_charges_map   :   aa_charges_map = self.get_atom_charges_map()
get_atom_radii_map   :   aa_radii_map = self.get_atom_radii_map()
get_config_vars   :   vars = sysconfig.get_config_vars()
get_group   :   translations = docking.get_group(translations, args.ngroups, args.ngroup)
get_matrix   :   m = docking_result.get_matrix(args.transid, args.rotid)
get_rotation   :   r = t.get_rotation(rotid)
get_tag_delimiter   :   tag_delimiter = ptools.Atomproperty.get_tag_delimiter()
get_translation   :   t = self.get_translation(transid)
glob   :   patternFiles = glob.glob(pathName)
group   :   addTest(suite, m.group(2), lineNo)
groupby   :   residue_list = itertools.groupby(self.atoms,
groupdict   :   minim = match.groupdict()
groups   :   g = m.groups()
has_duplicate_atoms   :   elif self.has_duplicate_atoms():
index   :   print nb/2.,min(ldist),int(round(dmin+(dmax-dmin)/2))+ldist.index(min(ldist))
info   :   log.info("{:s} found at {:s}".format(fortran_library_name, fortlib))
initialize_options   :   _build_ext.initialize_options(self)
insert   :   sys.path.insert(0, project_root)
isclass   :   if inspect.isclass(obj) and issubclass(obj, ResidueReductionError)]
is_incomplete   :   if not bead.is_incomplete()]
items   :   for residname, cgnames in residNames.items():
iteritems   :   for key, value in minim.iteritems():
join   :   prgname = os.path.join(thispath, "reduce_attract2.py")
keys   :   if namo in equiv.keys():
load   :   data = yaml.load(f)
main   :   unittest.main()
match   :   if regexp.match(k):
Matrix   :   self.mat = ptools.Matrix(self.nrows, self.ncols)
MatTrans2screw   :   s = ptools.MatTrans2screw(m)
minimize   :   lbfgs_minimizer.minimize(niter)
Movement   :   mov = ptools.Movement()
nonbon8   :   ener = forcefield.nonbon8(rec,lig,pl)
Normalize   :   AB.Normalize()
not_   :   sel_not_ca = sel_ca.not_()  # operator NOT
now   :   now = datetime.datetime.now()
number_of_minimizations   :   other.number_of_minimizations())
number_of_rotations   :   return [t.number_of_rotations() for t in self.translations]
number_of_translations   :   other.number_of_translations())
open   :   d = shelve.open(databasefile, flag='r')
optimize   :   optimized = cgopt.optimize(self.number_of_atoms,
optimize_charges   :   reducer.optimize_charges(args.delgrid)
outergrid   :   outergrid = surf.outergrid(grid, rec, distance_to_receptor)
parse_args   :   (options, args) = parser.parse_args()
parse_attract_output   :   output_test = ptools.io.parse_attract_output(out)
parse_command_line   :   cmd_args = ptools_cli.parse_command_line(args)
pop   :   line = clean.pop(0).split()
Popen   :   return subprocess.Popen(args, stdout=subprocess.PIPE).communicate()[0]
Print   :   self.mat.Print()
PrintMatrix   :   print lig.PrintMatrix()
PrintParam   :   for i in dna.PrintParam().split("\n"):
PrintPDB   :   print d.PrintPDB()
print_help   :   parser.print_help()
print_output_model   :   reducer.print_output_model(args.output)
radians   :   ABrotate (p, p+choice([vecti,vectj,vectk]), ligTemp, math.radians(uniform(-5, 5)))
Radius   :   radmax = rec.Radius()
RadiusGyration   :   radg = rec.RadiusGyration()
random   :   if random.random() <= math.exp(-delta) :
randrange   :   return random.randrange(-max_float, +max_float)
read   :   all = fobject.read()
readline   :   line = rotdat.readline().split()
readlines   :   lines = f.readlines()
readouterr   :   out, err = capfd.readouterr()
read_aminon   :   params = io.read_aminon(tmpfile.name)
read_attract_output   :   docking_result = ptools.io.read_attract_output(args.attract_output)
read_attract_parameters   :   nbminim, lignames, minimlist, rstk = ptools.io.read_attract_parameters(args.conf)
read_forcefield_from_reduced   :   io.read_forcefield_from_reduced(tmpfile.name)
read_name_conversion_file   :   self.read_name_conversion_file()
read_reduction_parameters   :   self.read_reduction_parameters()
read_rotations   :   rotations = docking.read_rotations()
read_rotdat   :   self.read_rotdat()
read_topology   :   self.read_topology()
read_translations   :   translations = docking.read_translations()
realpath   :   thisscript = os.path.realpath(__file__)
reduce   :   reducer.reduce(ignore_exceptions=ignore_exceptions)
Reduce   :   coarseRes = coarseResList[i].Reduce(resName, resId)
Reducer   :   reducer = ptools.reduce.Reducer(atomicname, redname)
remove   :   self._lstofAtoms.remove(atomtype)
removeclosest   :   outergrid = surf.removeclosest(outergrid, options.density)
rename_atoms_and_residues   :   self.rename_atoms_and_residues()
replace   :   return '"' + string.replace(str, '\\', '\\\\') + '"'
residuetag   :   key=lambda atom: atom.residuetag())
residue_reduction_errors   :   args.ignore_error = ptools.exceptions.residue_reduction_errors()
reverse   :   cgch.reverse()
Rigidbody   :   ligand = ptools.Rigidbody(args.ligand)
rigidXMat44   :   structure = extract.rigidXMat44(lig, s.ext.matrix)
Rise   :   mov = ptools.Rise(self.alpha)
Rmsd   :   return ptools.Rmsd(l1.CA().CreateRigid(), l2.CA().CreateRigid())
Roll   :   mov = ptools.Roll(self.alpha)
run_attract   :   docking.run_attract(lig, rec, translations, rotations, minimlist, ff_specs, args, ref, ftraj)
Screw   :   self.s = ptools.Screw()
search   :   elif world_re.search(line):
seed   :   random.seed(42)
seek   :   tmpfile.seek(0)
SelectAllAtoms   :   monoTest = mono1.SelectAllAtoms().CreateRigid()
SelectAtomID   :   # lastpoint = axpdb.SelectAtomID(407).CreateRigid() #
SelectAtomType   :   sseg2 = seg2.SelectAtomType("C1'").CreateRigid()
SelectChainId   :   #m1= groove.SelectChainId("A").CreateRigid()
SelectResidType   :   met1A = self.rig.SelectResidType("MET") & self.rig.SelectResRange(1, 5) & self.rig.SelectChainId("A")
SelectResRange   :   seg2= lig.SelectResRange(4,7).CreateRigid ()
SetAtom   :   self.r.SetAtom(3, atom)
SetAtomProperty   :   proch.SetAtomProperty(j,at)
SetChainId   :   at.SetChainId(letter)
SetCoords   :   ato.SetCoords(coo)
setCoords   :   out.setCoords(i, coords2)
setdefault   :   residuMap.setdefault(residueIdentifier, []).append(at)
SetResidId   :   atto.SetResidId(i+1)
SetRestraint   :   #     forcefield.SetRestraint(rstk)
SetRigid   :   atsel.SetRigid(rigidbody)
setRotation   :   rec.setRotation(False)
setTranslation   :   rec.setTranslation(False)
set_defaults   :   parser.set_defaults(func=run)
set_verbosity   :   log.set_verbosity(log.INFO)
Shift   :   mov = ptools.Shift(self.alpha)
sin   :   raynew = rayon*math.sin(hpori.angle/2)/math.sin(angnew/2)
size   :   k2 = d2.size()
Size   :   bp = dna[dna.Size()-1].GetRigidBody()
skipif   :   #skip_on_osx = pytest.mark.skipif(sys.platform == 'darwin',
Slide   :   mov = ptools.Slide(self.alpha)
sort   :   lChain.sort()
split   :   shift +=float(i.split()[20])
splitlines   :   lines = content.splitlines()
sqrt   :   distX = math.sqrt((D**2)-(startProj**2))#V
start   :   line = line[:e.start()]
startswith   :   elif ligne.startswith("MAT") :
stat   :   statout = os.stat(filename)
strftime   :   print "Finished at: ",now.strftime("%A %B %d %Y, %H:%M")
strip   :   if line.strip() and not line.startswith('#'):
sub   :   return re.sub(r'\b(E?TSM?_(ASSERT[A-Z_]*|FAIL))\s*\(',
submit   :   beadcreator.submit(atom)
superpose   :   sup = ptools.superpose(self.prot1, prot2)  # superpose(reference, mobile)
Surface   :   surf = ptools.Surface(30, 30, SOLVATION_PARAMETER_FILE)
surfpoint   :   grid = surf.surfpoint(rec, 1.4)
surfpointParams   :   surf.surfpointParams(5000, distance_to_receptor)
syncCoords   :   r2.syncCoords()
system   :   os.system("python applyscrew.py X2.pdb X4.pdb ABC_5.pdb --ch %s --nb 1 > pentamer.pdb" %letter)
tan   :   #print "beta ", beta*180./math.pi, "tg(beta) ", math.tan(beta)
Tilt   :   mov = ptools.Tilt(self.alpha)
toatom   :   return self.toatom().ToPdbString()
ToPdbString   :   #print a.ToPdbString(),
toString   :   print >> sys.stderr,"P:\t"+screw.point.toString()+"omega:\t"+screw.unitVector.toString()+"theta angle:\t [radian] "+str(screw.angle)+"\t [degree] "+ str(math.degrees(screw.angle))+"\ntrans:\t"+str(screw.normtranslation)
Translate   :   ligTemp.Translate(choice([vecti,vectj,vectk])*(uniform(-3, 3)))
Twist   :   mov = ptools.Twist(self.alpha)
uniform   :   raytmp = raynew + random.uniform(-3, 3)
unsafeGetCoords   :   r2.unsafeGetCoords(i, co2)
upper   :   ff = get_header_tokens()[1].upper()
urlopen   :   pdb = urllib2.urlopen("http://www.rcsb.org/pdb/files/%s.pdb" % pdbname)
values   :   for atom_parameters in self.atom_reduction_parameters.values()]
walk   :   # editing the 'dirnames' list will stop os.walk() from recursing into there.
warn   :   warnings.warn("only check the call, not the result")
warning   :   ptools.io.warning(msg)
write   :   sys.stderr.write("The bead %i of residue %s is incomplete. Please check your pdb!\n"
writelines   :   output.writelines(["static ", suite['name'], " ", suite['object'], ";\n\n"])
WritePDB   :   final.WritePDB(writefile)
